# Trabalho Pr√°tico - Compress√£o e Descompress√£o com Algoritmo de Huffman


Este projeto implementa um compressor e descompressor de arquivos usando o algoritmo de Huffman. Este algoritmo cria c√≥digos de tamanho vari√°vel para cada s√≠mbolo (caractere) baseados em sua frequ√™ncia de ocorr√™ncia, resultando em uma representa√ß√£o mais eficiente dos dados.

![Algoritmo de Huffman](https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/Huffman_tree_2.svg/440px-Huffman_tree_2.svg.png)

*Exemplo de uma √°rvore de Huffman*

## üß† Vis√£o Conceitual do Algoritmo

1. **An√°lise de Frequ√™ncia**: O algoritmo conta a ocorr√™ncia de cada caractere no arquivo.
2. **Constru√ß√£o da √Årvore**: Usando as frequ√™ncias, cria-se uma √°rvore onde caracteres mais frequentes ficam mais pr√≥ximos da raiz.
3. **Gera√ß√£o da Tabela de C√≥digos**: Para cada caractere, gera-se um c√≥digo √∫nico baseado em seu caminho na √°rvore.
4. **Compress√£o**: Os caracteres originais s√£o substitu√≠dos por seus c√≥digos bin√°rios.
5. **Descompress√£o**: Usando a √°rvore, converte-se os c√≥digos de volta aos caracteres originais.

## üî® Estrutura do Projeto

```
huffman/
‚îú‚îÄ‚îÄ Huffman.h         # Declara√ß√£o das estruturas e classe
‚îú‚îÄ‚îÄ Huffman.cpp       # Implementa√ß√£o do algoritmo de Huffman
‚îú‚îÄ‚îÄ main.cpp          # Gerenciamento de arquivos e interface do programa
‚îú‚îÄ‚îÄ Makefile          # Script para compila√ß√£o
‚îî‚îÄ‚îÄ test_huffman.py   # Script para teste autom√°tico (opcional)
```

## üíª Como Usar

### Compila√ß√£o
```bash
make
```

### Compress√£o
```bash
./huffman C arquivo_entrada arquivo_comprimido.huff
```

### Descompress√£o
```bash
./huffman D arquivo_comprimido.huff arquivo_saida
```

## üîç Funcionamento Detalhado

### 1. N√≥ da √Årvore de Huffman

Cada n√≥ na √°rvore armazena:
- Um caractere
- Sua frequ√™ncia
- Ponteiros para os filhos esquerdo e direito

```cpp
// De Huffman.h
struct Node {
    char ch;             // Caractere armazenado (s√≥ significativo em folhas)
    int freq;            // Frequ√™ncia do caractere
    Node *left, *right;  // Ponteiros para sub√°rvores
    // Construtor
    Node(char character, int frequency) : ch(character), freq(frequency), 
                                          left(nullptr), right(nullptr) {}
};
```

### 2. Tabela de Frequ√™ncia

O primeiro passo √© contar a frequ√™ncia de cada caractere no arquivo:

```cpp
// De Huffman.cpp
void Huffman::buildFrequencyTable(const std::string &data) {
    for (char ch : data) {
        frequencyTable[ch]++;  // Incrementa contador para cada caractere
    }
}
```

**Visualiza√ß√£o da Tabela de Frequ√™ncia:**
```
Caractere | Frequ√™ncia
----------|------------
   'a'    |     42
   'b'    |     15
   'c'    |     23
   ...    |     ...
```

### 3. Constru√ß√£o da √Årvore de Huffman

A √°rvore √© constru√≠da seguindo estes passos:

1. Criar um n√≥ folha para cada caractere
2. Ordenar os n√≥s por frequ√™ncia (e valor ASCII em caso de empate)
3. Repetidamente extrair os dois n√≥s de menor frequ√™ncia e combin√°-los em um novo n√≥
4. O √∫ltimo n√≥ remanescente √© a raiz da √°rvore

```cpp
// De Huffman.cpp
void Huffman::buildTree() {
    // Cria n√≥s para cada caractere e sua frequ√™ncia
    std::vector<Node*> nodes;
    for (auto &pair : frequencyTable) {
        nodes.push_back(new Node(pair.first, pair.second));
    }
    
    // Ordena os n√≥s por frequ√™ncia e valor ASCII (para determinismo)
    std::sort(nodes.begin(), nodes.end(), [](Node* a, Node* b) {
        if (a->freq == b->freq)
            return a->ch < b->ch;
        return a->freq < b->freq;
    });
    
    // Usa fila de prioridade para construir a √°rvore
    std::priority_queue<Node*, std::vector<Node*>, CompareNode> minHeap;
    for (auto node : nodes) {
        minHeap.push(node);
    }
    
    // Constr√≥i a √°rvore combinando os dois n√≥s de menor frequ√™ncia
    while (minHeap.size() > 1) {
        Node* left = minHeap.top();
        minHeap.pop();
        Node* right = minHeap.top();
        minHeap.pop();
        
        // Cria novo n√≥ interno com soma das frequ√™ncias
        Node* newNode = new Node('\0', left->freq + right->freq);
        newNode->left = left;
        newNode->right = right;
        minHeap.push(newNode);
    }
    
    // O √∫ltimo n√≥ √© a raiz da √°rvore
    if (!minHeap.empty()) {
        root = minHeap.top();
    }
}
```

**Visualiza√ß√£o da Constru√ß√£o da √Årvore:**
```
Etapa 1: N√≥s folha ordenados por frequ√™ncia
[a:42] [c:23] [b:15] [d:10] [e:5]

Etapa 2: Combinamos os dois menores (e:5 + d:10 = 15)
[a:42] [c:23] [b:15] [interno:15]
                      /      \
                   [d:10]    [e:5]

Etapa 3: Continuamos combinando
[a:42] [c:23] [interno:30]
                /       \
           [b:15]    [interno:15]
                      /      \
                   [d:10]    [e:5]

... e assim por diante at√© termos apenas a raiz
```

### 4. Gera√ß√£o da Tabela de C√≥digos

Para cada caractere, percorremos a √°rvore da raiz at√© a folha:
- Caminho √† esquerda = '0'
- Caminho √† direita = '1'

```cpp
// De Huffman.cpp
void Huffman::buildCodeTable(Node* node, const std::string &str) {
    if (!node)
        return;
    
    // Se √© um n√≥ folha, armazena o c√≥digo na tabela
    if (!node->left && !node->right) {
        codeTable[node->ch] = str;
    }
    
    // Recursivamente constr√≥i os c√≥digos para as sub√°rvores
    buildCodeTable(node->left, str + "0");   // Adiciona '0' para caminho √† esquerda
    buildCodeTable(node->right, str + "1");  // Adiciona '1' para caminho √† direita
}
```

**Visualiza√ß√£o da Tabela de C√≥digos:**
```
Caractere | C√≥digo Huffman
----------|---------------
   'a'    |      '0'
   'b'    |     '10'
   'c'    |    '110'
   't'    |   '1110'
   'e'    |   '1111'
```

### 5. Codifica√ß√£o dos Dados

Usando a tabela de c√≥digos, substitu√≠mos cada caractere por seu c√≥digo bin√°rio:

```cpp
// De Huffman.cpp
std::string Huffman::encode(const std::string &data) {
    std::string encodedStr;
    for (char ch : data) {
        encodedStr += codeTable[ch];  // Concatena o c√≥digo para cada caractere
    }
    return encodedStr;
}
```

**Exemplo:** A string "abacate" seria codificada como:
```
'a' = '0'
'b' = '10'
'a' = '0'
'c' = '110'
'a' = '0'
't' = '1110'
'e' = '1111'
Resultado: "0100110011101111"
```

### 6. Armazenamento Otimizado

Como trabalhamos com bits individuais, precisamos convert√™-los em bytes para armazenamento eficiente:

```cpp
// De main.cpp
std::string convertBitStringToBytes(const std::string &bitString, unsigned char &unusedBits) {
    // Preenche com zeros para completar o √∫ltimo byte se necess√°rio
    std::string padded = bitString;
    int remainder = padded.size() % 8;
    if (remainder != 0) {
        unusedBits = 8 - remainder;
        padded.append(unusedBits, '0');
    } else {
        unusedBits = 0;
    }
    
    // Converte grupos de 8 bits para bytes
    std::string byteString;
    for (size_t i = 0; i < padded.size(); i += 8) {
        unsigned char byte = 0;
        for (size_t j = 0; j < 8; j++) {
            byte <<= 1;                  // Desloca √† esquerda
            if (padded[i+j] == '1')
                byte |= 1;               // Define o bit menos significativo
        }
        byteString.push_back(byte);
    }
    return byteString;
}
```

**Visualiza√ß√£o da Convers√£o:**
```
String de bits: "10110101001..."
Agrupando em bytes: "10110101" "00100001" ...
```

### 7. Formato do Arquivo Comprimido

O arquivo comprimido armazena:
1. **Bits n√£o utilizados** (1 byte): N√∫mero de bits de preenchimento no √∫ltimo byte
2. **Tabela de frequ√™ncia**:
   - Tamanho da tabela (4 bytes)
   - Pares (caractere, frequ√™ncia) (5 bytes cada)
3. **Dados comprimidos**:
   - Tamanho da sequ√™ncia de bytes comprimidos em bytes (4 bytes)
   - Sequ√™ncia de bytes comprimidos

```cpp
// De main.cpp (fun√ß√£o compressFile)
// Escreve a quantidade de bits n√£o preenchidos no √∫ltimo byte (1 byte)
out.write(reinterpret_cast<char*>(&unusedBits), sizeof(unsigned char));

// Salva a tabela de frequ√™ncia para futura descompress√£o
int freqSize = huffman.frequencyTable.size();
out.write(reinterpret_cast<char*>(&freqSize), sizeof(int));
for (auto pair : huffman.frequencyTable) {
    out.write(&pair.first, sizeof(char));
    out.write(reinterpret_cast<char*>(&pair.second), sizeof(int));
}

// Escreve o tamanho do vetor de bytes codificados
int encodedByteLength = encodedBytes.size();
out.write(reinterpret_cast<char*>(&encodedByteLength), sizeof(int));

// Escreve os dados codificados (em bytes)
out.write(encodedBytes.c_str(), encodedBytes.size());
```

**O que √© `reinterpret_cast`?**
`reinterpret_cast` √© um operador de C++ usado para convers√£o entre tipos de ponteiros incompat√≠veis. Aqui, estamos usando-o para tratar vari√°veis num√©ricas como sequ√™ncias de bytes para armazenamento bin√°rio. Por exemplo:

```cpp
// De main.cpp
unsigned char unusedBits = 3;
// Converte ponteiro para unusedBits em ponteiro para char, 
// permitindo gravar os bytes brutos da vari√°vel
out.write(reinterpret_cast<char*>(&unusedBits), sizeof(unsigned char));
```

Isso permite escrever estruturas num√©ricas diretamente em arquivos bin√°rios.

### 8. Descompress√£o e Recupera√ß√£o da √Årvore

A chave para a descompress√£o est√° em reconstruir corretamente a √°rvore de Huffman. Este processo segue estes passos:

1. **Ler o cabe√ßalho do arquivo comprimido**:
   ```cpp
   // De main.cpp (fun√ß√£o decompressFile)
   unsigned char unusedBits = 0;
   in.read(reinterpret_cast<char*>(&unusedBits), sizeof(unsigned char));
   ```

2. **Recuperar a tabela de frequ√™ncia**:
   ```cpp
   // De main.cpp (fun√ß√£o decompressFile)
   int freqSize;
   in.read(reinterpret_cast<char*>(&freqSize), sizeof(int));
   
   for (int i = 0; i < freqSize; i++) {
       char ch;
       int freq;
       in.read(&ch, sizeof(char));
       in.read(reinterpret_cast<char*>(&freq), sizeof(int));
       huffman.frequencyTable[ch] = freq;
   }
   ```

3. **Reconstruir a √°rvore** usando exatamente o mesmo algoritmo da compress√£o:
   ```cpp
   // De main.cpp (fun√ß√£o decompressFile)
   huffman.buildTree();
   huffman.buildCodeTable(huffman.root, "");
   ```

O determinismo √© garantido pelo crit√©rio de desempate na constru√ß√£o da √°rvore - quando dois n√≥s t√™m a mesma frequ√™ncia, o de menor valor ASCII ter√° prioridade. Isso assegura que a mesma √°rvore seja constru√≠da tanto na compress√£o quanto na descompress√£o.

**Importante**: A pr√≥pria √°rvore n√£o √© armazenada no arquivo comprimido, apenas a tabela de frequ√™ncia, que √© suficiente para reconstruir a √°rvore com exatamente a mesma estrutura.

### 9. Processo de Decodifica√ß√£o

Ap√≥s reconstruir a √°rvore, os bytes comprimidos s√£o convertidos de volta √† sequ√™ncia de bits:

```cpp
// De main.cpp (fun√ß√£o decompressFile)
// Converte os bytes de volta para a string de bits
std::string encodedBitString = convertBytesToBitString(encodedBytes, unusedBits);
```

Ent√£o, a sequ√™ncia de bits √© decodificada percorrendo a √°rvore:

```cpp
// De Huffman.cpp
std::string Huffman::decode(const std::string &encodedData, Node* root) {
    std::string decodedStr;
    Node* current = root;
    
    // Para cada bit da sequ√™ncia codificada
    for (char bit : encodedData) {
        // Navega para esquerda (0) ou direita (1)
        if (bit == '0')
            current = current->left;
        else
            current = current->right;
        
        // Se chegamos a uma folha, encontramos um caractere
        if (!current->left && !current->right) {
            decodedStr += current->ch;  // Adiciona caractere recuperado
            current = root;             // Volta √† raiz para o pr√≥ximo caractere
        }
    }
    return decodedStr;
}
```

**Visualiza√ß√£o da Decodifica√ß√£o:**
```
Sequ√™ncia de bits: "0100110011101111"

Bit  | Caminho na √°rvore         | Caractere encontrado
-----|---------------------------|---------------------
'0'  | Raiz ‚Üí Esquerda (folha)   | 'a'
'1'  | Raiz ‚Üí Direita            | (continua)
'0'  | ‚Üí Esquerda (folha)        | 'b'
'0'  | Raiz ‚Üí Esquerda (folha)   | 'a'
'1'  | Raiz ‚Üí Direita            | (continua)
'1'  | ‚Üí Direita                 | (continua)
'0'  | ‚Üí Esquerda (folha)        | 'c'
...  | ...                       | ...

Decodificado: "abacate"
```

## üìä Desempenho e Considera√ß√µes

- **Taxa de Compress√£o**: Varia conforme a distribui√ß√£o de frequ√™ncia dos caracteres. Textos com muitos caracteres repetidos geralmente t√™m melhor compress√£o.
- **Tempo de Execu√ß√£o**: O algoritmo tem complexidade O(n log n), onde n √© o n√∫mero de caracteres √∫nicos no arquivo.
- **Uso de Mem√≥ria**: Proporcional ao n√∫mero de caracteres √∫nicos, n√£o ao tamanho total do arquivo.

## üîÑ Fluxo Completo do Programa

### Compress√£o:
1. L√™ o arquivo de entrada
2. Cria a tabela de frequ√™ncia
3. Constr√≥i a √°rvore de Huffman
4. Gera a tabela de c√≥digos bin√°rios
5. Codifica o texto original usando os c√≥digos
6. Converte a sequ√™ncia de bits em bytes
7. Salva o arquivo comprimido com cabe√ßalho e dados

### Descompress√£o:
1. L√™ o arquivo comprimido
2. Extrai o cabe√ßalho (bits n√£o utilizados e tabela de frequ√™ncia)
3. Reconstr√≥i a √°rvore de Huffman
4. Converte os bytes em sequ√™ncia de bits
5. Decodifica a sequ√™ncia de bits usando a √°rvore
6. Salva o texto decodificado no arquivo de sa√≠da

## üß™ Testando o Programa

Voc√™ pode testar o programa manualmente comprimindo e descomprimindo arquivos, ou usar o script fornecido para teste automatizado.

### Como usar o script de testes  

1. Certifique-se de que o execut√°vel `huffman` est√° no mesmo diret√≥rio que o script.
2. Execute o script com o comando:

   ```bash
   python3 test_huffman.py
   ```

3. O script ir√°:
   - Gerar 10 arquivos de teste aleat√≥rios com tamanhos entre 256 bytes e 8 MB.
   - Comprimir e descomprimir cada arquivo usando `huffman`.
   - Verificar se os arquivos descomprimidos s√£o id√™nticos aos originais.
   - Exibir os resultados de cada teste no formato:

     ```
     Teste  1 | Original:   1024 bytes | Comprimido:    512 bytes | ‚úÖ
     Teste  2 | Original:  524288 bytes | Comprimido:  200000 bytes | ‚úÖ
     ```

   - Perguntar se deseja gerar mais 10 casos ou encerrar e apagar todos os arquivos criados.

4. Para encerrar e excluir todos os arquivos tempor√°rios, digite `E` quando o script perguntar.

